<!doctype html>
<html>
<head>
<meta charset='utf-8'/>
<meta name='viewport' content='width=device-width,initial-scale=1'/>
<title>CO2-Optimized Route (Interactive)</title>
<link rel='stylesheet' href='https://unpkg.com/leaflet@1.9.4/dist/leaflet.css'/>
<script src='https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'></script>
<style>
  html,body,#map{height:100%;margin:0}
  .panel{position:absolute;left:10px;top:10px;background:#fff;padding:10px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.15);z-index:9999;font-family:sans-serif}
  .controls{margin-top:8px}
  .legend{background:#fff;padding:6px;border-radius:6px;box-shadow:0 1px 6px rgba(0,0,0,.2)}
  .btn{display:inline-block;padding:6px 8px;background:#007bff;color:#fff;border-radius:6px;text-decoration:none;margin-right:6px}
</style>
</head>
<body>
<div id='map'></div>
<div class='panel' id='infoPanel'>
<b>CO2-Optimized Route</b><br/>
Total CO2: <span id='totalCo2'>4745.52</span> g<br/>
Total time (car): <span id='totalCar'>51.8</span> min
<br/>
<div class='controls'>Mode: <select id='modeSelect'><option value='car'>Car</option><option value='bike'>Bike</option><option value='walk'>Walk</option></select></div>
<div class='controls'><a id='playBtn' class='btn'>Play</a><a id='pauseBtn' class='btn' style='background:#6c757d'>Pause</a><a id='downloadBtn' class='btn' style='background:#28a745'>Download GeoJSON</a></div>
<div style='margin-top:8px'><small>Click a segment for details. Open DevTools Console for debug logs.</small></div>
</div>
<script>
var map = L.map('map').setView([30.316500,78.032200], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'&copy; OpenStreetMap'}).addTo(map);
var nodes = [
  {lat:30.316500, lon:78.032200, name:"Dehradun"},
  {lat:29.945700, lon:78.164200, name:"Haridwar"}
];
function km_to_min(d_km, speed_kmph){ return (d_km / speed_kmph) * 60.0; }
var segments = [
  {u:0, v:1, dist:43.141049, traffic:1.000000, car_min:51.769, bike_min:172.564, walk_min:517.693}
];
var CAR_CO2 = 110.000000;
for(var i=0;i<segments.length;i++){ segments[i].co2 = segments[i].dist * segments[i].traffic * CAR_CO2; }
function trafficColor(f){
  var c = Math.max(0, Math.min(1.0, (f-1.0)/3.0));
  var r = Math.floor(255 * c);
  var gcol = Math.floor(200 * (1-c));
  return 'rgb('+r+','+gcol+',30)';
}
var segmentLayers = L.layerGroup();
var nodeLayer = L.layerGroup();

function drawStraight(nodes){
  var latlngs = nodes.map(n => [n.lat, n.lon]);
  return L.polyline(latlngs, {weight:6, color:trafficColor(1.0), opacity:0.9}).addTo(segmentLayers);
}

function buildOSRMUrlFromNodes(nodes){
  return nodes.map(n => encodeURIComponent(n.lon) + ',' + encodeURIComponent(n.lat)).join(';');
}

async function osrmRouteForChunk(nodesChunk){
  if(!nodesChunk || nodesChunk.length < 2) return null;
  var coordStr = buildOSRMUrlFromNodes(nodesChunk);
  var url = 'https://router.project-osrm.org/route/v1/driving/' + coordStr + '?overview=full&geometries=geojson&steps=false&alternatives=false';
  var resp = await fetch(url);
  if(!resp.ok) throw new Error('OSRM request failed: ' + resp.status);
  var j = await resp.json();
  if(!j.routes || !j.routes[0] || !j.routes[0].geometry) throw new Error('No route in OSRM response');
  return j.routes[0].geometry.coordinates.map(function(c){ return [c[1], c[0]]; });
}

async function drawSnappedSingle(nodes){
  if(!nodes || nodes.length < 2) return drawStraight(nodes);
  const CHUNK_WAYPOINTS = 10;
  var allLatLngs = [];
  try{
    if(nodes.length <= CHUNK_WAYPOINTS){
      var coords = await osrmRouteForChunk(nodes);
      if(coords && coords.length) allLatLngs = allLatLngs.concat(coords);
    } else {
      for(var i=0;i<nodes.length;i += (CHUNK_WAYPOINTS-1)){
        var slice = nodes.slice(i, Math.min(nodes.length, i + CHUNK_WAYPOINTS));
        try{
          var seg = await osrmRouteForChunk(slice);
          if(seg && seg.length){
            if(allLatLngs.length && seg.length && Math.abs(allLatLngs[allLatLngs.length-1][0] - seg[0][0]) < 1e-6 && Math.abs(allLatLngs[allLatLngs.length-1][1] - seg[0][1]) < 1e-6) seg.shift();
            allLatLngs = allLatLngs.concat(seg);
          }
        }catch(errChunk){
          console.warn('OSRM chunk failed, falling back for that chunk:', errChunk);
          var fallback = slice.map(function(n){ return [n.lat, n.lon]; });
          if(allLatLngs.length && fallback.length && Math.abs(allLatLngs[allLatLngs.length-1][0] - fallback[0][0]) < 1e-6 && Math.abs(allLatLngs[allLatLngs.length-1][1] - fallback[0][1]) < 1e-6) fallback.shift();
          allLatLngs = allLatLngs.concat(fallback);
        }
      }
    }
    if(!allLatLngs || allLatLngs.length === 0){ console.warn('OSRM returned no coordinates â€” falling back to straight polyline.'); return drawStraight(nodes); }
    var pl = L.polyline(allLatLngs, {weight:6, color:trafficColor(1.0), opacity:0.95}).addTo(segmentLayers);
    return pl;
  }catch(e){
    console.error('OSRM overall failed:', e);
    return drawStraight(nodes);
  }
}

(async function(){
  var nodesArr = nodes;
  try{
    for(var i=0;i<nodesArr.length;i++){
      L.marker([nodesArr[i].lat,nodesArr[i].lon]).addTo(nodeLayer).bindPopup(nodesArr[i].name);
    }
    nodeLayer.addTo(map);
    var pl = null;
    try{ pl = await drawSnappedSingle(nodesArr); } catch(e){ console.warn('drawSnappedSingle failed, using straight fallback:', e); pl = drawStraight(nodesArr); }
    segmentLayers.addTo(map);
    try{ if(pl && pl.getBounds) map.fitBounds(pl.getBounds().pad ? pl.getBounds().pad(0.2) : pl.getBounds(), {padding:[20,20]}); } catch(e) { console.warn('fitBounds failed:', e); }
    var coordsAll = [];
    if(pl && pl.getLatLngs && pl.getLatLngs().length) coordsAll = pl.getLatLngs().map(function(ll){ return [ll.lat, ll.lng]; });
    if(coordsAll.length === 0) coordsAll = nodesArr.map(function(n){ return [n.lat, n.lon]; });
    var animMarker = L.circleMarker(coordsAll[0], {radius:8, color:'#000'}).addTo(map);
    var animIndex = 0; var animPlaying = false;
    function stepAnim(){ if(!animPlaying) return; animIndex += 0.02; var idx = Math.floor(animIndex); if(idx >= coordsAll.length-1){ animIndex = 0; idx = 0; } var a = coordsAll[idx], b = coordsAll[Math.min(idx+1, coordsAll.length-1)]; var t = animIndex - idx; var lat = a[0]*(1-t) + b[0]*t; var lng = a[1]*(1-t) + b[1]*t; animMarker.setLatLng([lat,lng]); setTimeout(stepAnim, 100); }
    document.getElementById('playBtn').onclick = function(){ animPlaying = true; stepAnim(); };
    document.getElementById('pauseBtn').onclick = function(){ animPlaying = false; };
    document.getElementById('downloadBtn').onclick = function(){
      var feat = { type: 'Feature', properties:{totalCo2: 4745.515}, geometry: { type:'LineString', coordinates: coordsAll.map(function(c){ return [c[1],c[0]]; }) } };
      var geo = { type:'FeatureCollection', features:[feat] };
      var data = 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(geo));
      var a = document.createElement('a'); a.href = data; a.download = 'route.geojson'; document.body.appendChild(a); a.click(); document.body.removeChild(a);
    };
  }catch(errMain){
    console.error('Map drawing failed:', errMain);
    try{ drawStraight(nodes); segmentLayers.addTo(map); } catch(e){}
  }
})();
var totalCar = 51.769;
var totalBike = 172.564;
var totalWalk = 517.693;
document.getElementById('modeSelect').onchange = function(){ var m = this.value; if(m=='car'){ document.getElementById('totalCar').textContent = totalCar.toFixed(1); } else if(m=='bike'){ document.getElementById('totalCar').textContent = totalBike.toFixed(1); } else { document.getElementById('totalCar').textContent = totalWalk.toFixed(1); } };
</script>
</body>
</html>
